import numpy as np
import skimage.measure as skm
import skimage.feature as skf
import scipy.ndimage.morphology as scm
import scipy.optimize as sco
from functools import reduce
import numpy.ma as ma
from skimage.morphology import dilation, disk

import logging
logging.basicConfig()
logger = logging.getLogger(__name__)


import matplotlib.pyplot as plt
plt.ion()

def generate_mask(image, modificado=False):
    """
    Generate a mask from a gray image. This mask contains the disk,
    the rectangle and the annulus and its so conceived as to be gerchberg-completed
    afterwards.
    """

    imth = image > ( np.mean(image) + 0.2*np.std(image) )
    labeled, N_objects = skm.label( imth, connectivity=2, return_num = True)
    objects = skm.regionprops(labeled)

    props = [(object.area, object.label, object.solidity, object.extent) for object in objects]

    # sort regionprops by area*solidity*extent, in ascending order
    props.sort(key=lambda x: x[0]*x[2]*x[3])



    mask_of_disk_alone = ( labeled == props[-1][1] )
    mask_of_rect_alone = ( labeled == props[-2][1] )
    mask_of_annulus_alone = ( labeled == props[-3][1] )
    if modificado==True:
        ### OJO QUE ACA LO MODIFIQUE A MANO para 09/10
        mask_of_rect_alone = ( labeled == props[-3][1] )
        mask_of_annulus_alone = ( labeled == props[-5][1] )

    # Relleno la mascara del anillo por si quedaron agujeros
    mask_of_annulus_alone = dilation(mask_of_annulus_alone, disk(2))
    xc_disk, yc_disk, R_disk = determine_properties_of_disk(mask_of_disk_alone)
    xc_ext_annulus, yc_ext_annulus, Rext_annulus = determine_properties_of_disk(mask_of_annulus_alone)
    xc_int_annulus, yc_int_annulus, Rint_annulus  = determine_properties_of_disk(mask_int_annulus(mask_of_annulus_alone))

    # Both the internal and external fit of the annulus have the same center
    xc_annulus, yc_annulus = np.mean([xc_ext_annulus, xc_int_annulus]), np.mean([yc_ext_annulus, yc_int_annulus])

    R_disk = R_disk + 4 # this only affects the R_disk variable, not the mask itself
    Rint_annulus = Rint_annulus + 5
    Rext_annulus = Rext_annulus + 5

    xc_rect, yc_rect, sl_rect = determine_properties_of_rect(mask_of_rect_alone)

    mask = ( mask_of_disk_alone + mask_of_rect_alone + mask_of_annulus_alone)

    return mask, [xc_disk, yc_disk], R_disk, [xc_rect, yc_rect], sl_rect, [xc_annulus, yc_annulus], Rext_annulus, Rint_annulus, mask_of_disk_alone, mask_of_rect_alone, mask_of_annulus_alone

def mask_int_annulus(mask_annulus):
    """
    Internal funciton which labels the regions in 'mask_annulus' and selects its interior.
    """
    imth = mask_annulus*1 + np.ones(shape=np.shape(mask_annulus))
    labeled, N_objects = skm.label(imth, connectivity=2, return_num = True)
    objects = skm.regionprops(labeled)

    props = [(object.area, object.label, object.solidity, object.extent) for object in objects]

    # sort regionprops by area*solidity*extent, in ascending order
    props.sort(key=lambda x: x[0]*x[2]*x[3])
    interior = ( labeled == props[-1][1] )
    return interior

def view_annulus_mask(image):
    """
    Visualize annulus mask from a gray image as generated by generate_mask.
    """
    mask, xy, R, xyr, sr, xya, rea, ria, md, mr, ma = generate_mask(image)
    fig = plt.figure()
    plt.imshow(image)
    plt.set_cmap('gray')
    plt.colorbar()
    ax = plt.gca()
    #ax.axhline(xyea[1], linestyle=':',   color='w') # horizontal lines
    #ax.axvline(xyea[0], linestyle=':',   color='w') # vertical lines
    #ax.axhline(xya[1]+rea, linestyle=':', color='w') # horizontal lines
    #ax.axvline(xya[0]+rea, linestyle=':', color='w') # vertical lines
    #ax.axhline(xya[1]-rea, linestyle=':', color='w') # horizontal lines
    #ax.axvline(xya[0]-rea, linestyle=':', color='w') # vertical lines
    plt.plot(xya[0], xya[1],'ro')
    circ_ext = plt.Circle(xya, radius=rea, edgecolor='r', facecolor='None', linestyle='--')
    circ_int = plt.Circle(xya, radius=ria, edgecolor='r', facecolor='None', linestyle='--')
    ax.add_artist(circ_ext)
    ax.add_artist(circ_int)
    plt.title('Generated mask')



def view_disk_mask(image):
    """
    Visualize disk mask from a gray image as generated by generate_mask.
    """
    mask, xy, R, xyr, sr, xya, rea, ria, md, mr, ma = generate_mask(image)
    fig = plt.figure()
    plt.imshow(image)
    plt.set_cmap('gray')
    plt.colorbar()
    ax = plt.gca()
    ax.axhline(xy[1], linestyle=':',   color='w') # horizontal lines
    ax.axvline(xy[0], linestyle=':',   color='w') # vertical lines
    ax.axhline(xy[1]+R, linestyle=':', color='w') # horizontal lines
    ax.axvline(xy[0]+R, linestyle=':', color='w') # vertical lines
    ax.axhline(xy[1]-R, linestyle=':', color='w') # horizontal lines
    ax.axvline(xy[0]-R, linestyle=':', color='w') # vertical lines
    plt.plot(xy[0], xy[1],'ro')
    circ = plt.Circle(xy, radius=R, edgecolor='r', facecolor='None', linestyle='--')
    ax.add_artist(circ)
    plt.title('Generated mask')


def determine_properties_of_disk(image):
	"""
	Internal function which determines the position of the center of the disk
	as well as its radius.
	"""
	try:
		border = skf.canny( scm.binary_fill_holes(image) )
		xyb = np.argwhere(border == 1)
		xb, yb = xyb[:,1], xyb[:,0]
		center_estimate = np.mean(xb), np.mean(yb)

		def calculate_radius(xc, yc):
			return np.sqrt( (xb-xc)**2 + (yb-yc)**2 )


		def calculate_distance(c):
			Ri = calculate_radius(*c)
			return Ri - Ri.mean()

		center_position, ier = sco.leastsq(calculate_distance, center_estimate)
		xc, yc = center_position
		radius = calculate_radius(*center_position).mean()
	except:
		border = skf.canny(image)
		xyb = np.argwhere(border == 1)
		xb, yb = xyb[:,1], xyb[:,0]
		center_estimate = np.mean(xb), np.mean(yb)

		def calculate_radius(xc, yc):
			return np.sqrt( (xb-xc)**2 + (yb-yc)**2 )


		def calculate_distance(c):
			Ri = calculate_radius(*c)
			return Ri - Ri.mean()

		center_position, ier = sco.leastsq(calculate_distance, center_estimate)
		xc, yc = center_position
		radius = calculate_radius(*center_position).mean()


	return xc, yc, radius


def determine_properties_of_rect(mask_of_rect_alone):
    """
    Determines center of rectangular region, useful for FTP analysis.
    """

    # Properties of rectangle alone
    prop_rect = skm.regionprops(mask_of_rect_alone.astype(int))[0]
    xc_rect, yc_rect = prop_rect.centroid
    Lx, Ly = prop_rect.major_axis_length, prop_rect.minor_axis_length
    L = np.min([Lx, Ly]) - 5
    return int(xc_rect), int(yc_rect), int(L/2)


def generate_average_image(dset):
    """
    Generate average of images (typically for gray and reference ones).
    Input is a pointer to a dataset in the HDF5 file.
    """

    # Load each horizontal slice and add, instead of loading all set to ram!
    Xsize, Ysize, Nslices = dset.shape
    accum = np.zeros((Xsize, Ysize))

    for i in range(Nslices):
        accum = accum + dset[:,:, i]

    return accum/Nslices


def determine_logging_level():
    """
    Internal. Used to determine loggging level.
    """
    return None

def factors(n):
    divisors =  set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(pow(n, 0.5) + 1)) if n % i == 0)))
    return sorted(np.array(list(divisors), dtype=int))

def find_nearest(array, value):
    array = np.asarray(array)
    idx = (np.abs(array - value)).argmin()
    return idx

def divisor(M):
    divisores = factors(M)
    divisiones = M//np.array(divisores)
    index = find_nearest(divisiones, 100)
    div = divisores[index]
    return div

def polar2cart(r, theta, center):

    x = r  * np.cos(theta) + center[0]
    y = r  * np.sin(theta) + center[1]
    return x, y

def img2polar(img, center = None, final_radius= None, initial_radius = None, phase_width = 3000):
    """
    Function that converts image to polar coordinates.

    """

    if initial_radius is None:
        initial_radius = 0
    if center is None:
        center = [int(len(img)/2), int(len(img)/2)]
    if final_radius is None:
        final_radius = int(len(img)/2)

    theta , R = np.meshgrid(np.linspace(0, 2*np.pi, phase_width),
                            np.arange(initial_radius, final_radius))

    Xcart, Ycart = polar2cart(R, theta, center)

    Xcart = Xcart.astype(int)
    Ycart = Ycart.astype(int)

    if img.ndim ==3:
        polar_img = img[Ycart,Xcart,:]
        polar_img = np.reshape(polar_img,(final_radius-initial_radius,phase_width,3))
    else:
        polar_img = img[Ycart,Xcart]
        polar_img = np.reshape(polar_img,(final_radius-initial_radius,phase_width))

    return polar_img

def sum_values(masked_img):
    suma = np.zeros(shape=masked_img.shape[0])
    for i in range(masked_img.shape[0]):
        suma[i] = np.sum((ma.getmask(masked_img)==False)[i])
    return suma

def find_first_and_last(arr, x):
    first = -1
    last = -1
    for i in range(0,len(arr)) :
        if (x != arr[i]) :
            continue
        if (first == -1) :
            first = i
        last = i
    return first, last

def find_index_of_false_values(masked_img):
    total_values = sum_values(masked_img)
    first_idx, last_idx = find_first_and_last(total_values, masked_img.shape[1])
    return first_idx, last_idx
